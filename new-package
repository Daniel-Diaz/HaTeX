#!/usr/bin/env stack
-- stack --resolver lts-15.11 script --package template-haskell

{-# LANGUAGE TemplateHaskell, TemplateHaskellQuotes #-}

import Data.List

import Language.Haskell.TH.Ppr(pprint)
import Language.Haskell.TH.Syntax

import System.Console.GetOpt
import System.Environment

docSection :: String -> IO ()
docSection = putStrLn . ("    -- * " <>)

tPackageName :: Type
tPackageName = ConT (mkName "PackageName")

tOption :: Type
tOption = ForallT [] [AppT (ConT (mkName "LaTeXC")) (VarT l)] (VarT l)
    where l = mkName "l"

_stringLiteral :: String -> Clause
_stringLiteral pn = Clause [] (NormalB (LitE (StringL pn))) []

packageOption :: String -> [Dec]
packageOption opt = [
    SigD nopt tOption
  , FunD nopt [_stringLiteral opt]
  ]
  where nopt = mkName opt

packageConstant :: String -> Name
packageConstant = mkName . ('p':)

optionConstant :: String -> Name
optionConstant = mkName

declarations :: Name -> String -> [String] -> [[Dec]]
declarations pName name opts = [
    SigD pName tPackageName
  , FunD pName [_stringLiteral name]
  ] : map packageOption opts

data LaTeXPackage = LaTeXPackage { packageName :: String, packageOptions :: [String], pragmas :: [String] }

initialPackage :: LaTeXPackage
initialPackage = LaTeXPackage "" [] ["OverloadedStrings"]

header :: String
header = "Usage: stack new-package [OPTION...]"

-- options :: [OptDescr (LaTeXPackage -> LaTeXPackage)]
-- options = [
--     Option ['p'] ["package-name"]   (ReqArg (\s l -> l { packageName=s }) "package-name") "The name of the package"
--   , Option ['o'] ["package-option"] (ReqArg (\o l@LaTeXPackage{packageOptions=os} -> l {packageOptions=(o:os)}) "option-name")  "library directory"
--   , Option ['r'] ["pragma"] (ReqArg (\p l@LaTeXPackage{pragmas=ps} -> l {pragmas=(p:ps)}) "pragma-name")  "pragmas used in the module"
--   ]

haddock :: [String] -> String
haddock [] = []
haddock (l:ls) = unlines (("-- | " ++ l) : map ("-- " ++) ls)

main = do
    argv <- getArgs
    l@LaTeXPackage{packageName=n,packageOptions=os, pragmas=ps} <- case getOpt Permute options argv of
         (o,_,[]) -> pure (foldr ($) initialPackage o)
         (_,_,errs) -> ioError (userError (concat errs ++ usageInfo header options))
    let pName = packageConstant n
    putStrLn ("{-# LANGUAGE " <> (intercalate ", " (sort ps)) <> " #-}\n\nmodule Text.LaTeX.Packages." <> n <> " (")
    docSection (n <> " package")
    putStrLn ("    " <> nameBase pName)
    docSection "Package options"
    docSection "Types"
    docSection "Functions"
    putStrLn "  )"
    r <- runQ (pure (declarations pName n os))
    putStrLn (haddock ["The '???' package.", "", "> usepackage [] p????"])
    putStrLn (haddock ["Package option ???"])
    -- | The '???' package.
--
-- > usepackage [] p???
    mapM_ (putStrLn . ('\n':) . pprint) r -- "Constructing a new package"

-- vim:ft=haskell
